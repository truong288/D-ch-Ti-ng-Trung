import os   #CH·∫†Y OK
import json
import hashlib
from datetime import datetime
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import (Application, CommandHandler, MessageHandler,
                          ContextTypes, filters, CallbackQueryHandler)
from deep_translator import GoogleTranslator
from pypinyin import pinyin, Style
import openpyxl
from openpyxl.utils import get_column_letter
from telegram.ext import MessageHandler, filters
from stay_alive import keep_alive


keep_alive()

# ==== File c·∫•u h√¨nh ====
ADMIN_FILE = "admins.json"
DB_FILE = "translation_db.json"
TEMP_FILE = "temp_callback_data.json"


# ==== Qu·∫£n l√Ω Admin ====
def load_admins():
    try:
        with open(ADMIN_FILE, "r", encoding="utf-8") as f:
            return set(json.load(f))
    except:
        save_admins(set())
        return set()


def save_admins(admin_set):
    with open(ADMIN_FILE, "w", encoding="utf-8") as f:
        json.dump(list(admin_set), f, ensure_ascii=False, indent=2)


admins = load_admins()


def is_admin(user_id):
    return str(user_id) in admins


# ==== Qu·∫£n l√Ω Database ====
class TranslationDatabase:

    def __init__(self):
        self.data = {"history": [], "saved_phrases": {}}
        self.load_db()

    def load_db(self):
        try:
            with open(DB_FILE, "r", encoding="utf-8") as f:
                self.data = json.load(f)
        except (FileNotFoundError, json.JSONDecodeError):
            self.save_db()

    def save_db(self):
        with open(DB_FILE, "w", encoding="utf-8") as f:
            json.dump(self.data, f, ensure_ascii=False, indent=2)

    def save_phrase(self, user_id, phrase, translation):
        if str(user_id) not in self.data["saved_phrases"]:
            self.data["saved_phrases"][str(user_id)] = {}
        self.data["saved_phrases"][str(user_id)][phrase] = translation
        self.save_db()

    def delete_phrase(self, user_id, phrase):
        if str(user_id) in self.data["saved_phrases"]:
            if phrase in self.data["saved_phrases"][str(user_id)]:
                del self.data["saved_phrases"][str(user_id)][phrase]
                self.save_db()
                return True
        return False

    def search_phrases(self, user_id, keyword):
        if str(user_id) not in self.data["saved_phrases"]:
            return {}
        return {
            k: v
            for k, v in self.data["saved_phrases"][str(user_id)].items()
            if keyword.lower() in k.lower() or keyword.lower() in v.lower()
        }

    def add_history(self, user_id, original, translated, direction):
        self.data["history"].append({
            "user_id": str(user_id),
            "original": original,
            "translated": translated,
            "direction": direction,
            "timestamp": datetime.now().isoformat()
        })
        self.save_db()

    def get_user_history(self, user_id, limit=5):
        user_history = [
            item for item in self.data["history"]
            if item["user_id"] == str(user_id)
        ]
        return sorted(user_history, key=lambda x: x["timestamp"],
                      reverse=True)[:limit]


db = TranslationDatabase()

# ==== L∆∞u tr·ªØ callback_data t·∫°m b·ªÅn v·ªØng ====


def load_temp_data():
    try:
        with open(TEMP_FILE, "r", encoding="utf-8") as f:
            return json.load(f)
    except:
        return {}


def save_temp_data(data):
    with open(TEMP_FILE, "w", encoding="utf-8") as f:
        json.dump(data, f, ensure_ascii=False, indent=2)


temp_data = load_temp_data()


# ==== H√†m h·ªó tr·ª£ t·∫°o ID ng·∫Øn t·ª´ text ====
def short_id(text):
    return hashlib.md5(text.encode()).hexdigest()[:10]


# ==== D·ªãch ng√¥n ng·ªØ & Phi√™n √¢m ====
async def translate_chunk(text):
    try:
        if any('\u4e00' <= char <= '\u9fff' for char in text):
            translated = GoogleTranslator(source='zh-CN',
                                          target='vi').translate(text)
            pinyin_text = " ".join(
                [item[0] for item in pinyin(text, style=Style.TONE)])
            return {
                "translation": translated,
                "direction": "zh-vi",
                "pinyin": pinyin_text
            }

        vietnamese_chars = set('aƒÉ√¢bcdƒëe√™ghiklmno√¥∆°pqrstu∆∞vxy')
        if any(char in vietnamese_chars for char in text.lower()):
            translated = GoogleTranslator(source='vi',
                                          target='zh-CN').translate(text)
            pinyin_text = " ".join(
                [item[0] for item in pinyin(translated, style=Style.TONE)])
            return {
                "translation": translated,
                "direction": "vi-zh",
                "pinyin": pinyin_text
            }
    except Exception as e:
        print(f"L·ªói khi d·ªãch: {e}")
    return None


async def detect_and_translate(text, user_id=None):
    result = await translate_chunk(text)
    if result and user_id:
        db.add_history(user_id, text, result["translation"],
                       result["direction"])
    return result


# ==== G·ª≠i k·∫øt qu·∫£ d·ªãch v·ªõi n√∫t l∆∞u (callback_data ƒë√£ l∆∞u v√†o file) ====
async def send_translation_with_save_button(update: Update,
                                            context: ContextTypes.DEFAULT_TYPE,
                                            text: str, result: dict):
    key = short_id(text)

    # L∆∞u b·ªÅn callback data v√†o file
    temp_data[key] = {"text": text, "translation": result["translation"]}
    save_temp_data(temp_data)

    keyboard = [[
        InlineKeyboardButton("üíæ L∆∞u c·ª•m t·ª´ n√†y", callback_data=f"save_{key}")
    ]]
    reply_markup = InlineKeyboardMarkup(keyboard)

    direction_map = {"zh-vi": "üá®üá≥‚Üíüáªüá≥", "vi-zh": "üáªüá≥‚Üíüá®üá≥"}
    response = f"{direction_map.get(result['direction'], '')}\nüî§ {result['translation']}\n"

    if result["pinyin"]:
        response += f"üó£Ô∏è Phi√™n √¢m: {result['pinyin']}\n"

    await context.bot.send_message(chat_id=update.message.chat.id,
                                   text=response,
                                   reply_markup=reply_markup)


# ==== X·ª≠ l√Ω callback khi nh·∫•n n√∫t L∆∞u ====
async def button_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()

    if query.data.startswith("save_"):
        key = query.data[5:]
        user_id = query.from_user.id

        info = temp_data.get(key)
        if not info:
            await query.edit_message_text("‚ùå Kh√¥ng t√¨m th·∫•y c·ª•m t·ª´ ƒë·ªÉ l∆∞u.")
            return

        db.save_phrase(user_id, info["text"], info["translation"])
        await query.edit_message_text(
            text=f"{query.message.text}\n\n‚úÖ ƒê√£ l∆∞u: '{info['text']}'")


# ==== X·ª≠ l√Ω l·ªánh t·ª´ ng∆∞·ªùi d√πng ====
async def handle_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    text = update.message.text.strip()
    user_id = update.message.from_user.id

    if '@' in text:
        text = text.split('@')[0]

    elif text == '/mysaved':
        if not is_admin(user_id):
            await update.message.reply_text("‚ùå B·∫°n kh√¥ng c√≥ quy·ªÅn admin.")
            return

        phrases = db.data["saved_phrases"]
        if phrases:
            msg_lines = ["üìö T·∫•t c·∫£ c·ª•m t·ª´ ƒë√£ l∆∞u:"]
            for user_id_key, user_phrases in phrases.items():
                msg_lines.append(f"User {user_id_key}:")
                for phrase, translation in user_phrases.items():
                    msg_lines.append(f"{phrase} ‚Üí {translation}")
            msg = "\n".join(msg_lines)
            await update.message.reply_text(msg[:4000])
        else:
            await update.message.reply_text("‚ùå Ch∆∞a c√≥ c·ª•m t·ª´ n√†o ƒë∆∞·ª£c l∆∞u.")

    elif text == '/saved':
        phrases = db.data["saved_phrases"].get(str(user_id), {})
        if phrases:
            msg = "\n".join(f"‚Ä¢ {k} ‚Üí {v}" for k, v in phrases.items())
            await update.message.reply_text(f"üìö C·ª•m t·ª´ ƒë√£ l∆∞u:\n{msg[:4000]}")
        else:
            await update.message.reply_text("‚ùå B·∫°n ch∆∞a l∆∞u c·ª•m t·ª´ n√†o.")

    elif text.startswith('/save '):
        phrase = text[6:].strip()
        result = await detect_and_translate(phrase, user_id)
        if result:
            db.save_phrase(user_id, phrase, result["translation"])
            await update.message.reply_text(f"‚úÖ ƒê√£ l∆∞u: '{phrase}'")
        else:
            await update.message.reply_text("‚ö†Ô∏è Kh√¥ng th·ªÉ d·ªãch c·ª•m t·ª´ n√†y.")

    elif text.startswith('/delete '):
        phrase = text[8:].strip()
        if db.delete_phrase(user_id, phrase):
            await update.message.reply_text(f"‚úÖ ƒê√£ x√≥a: '{phrase}'")
        else:
            await update.message.reply_text("‚ùå Kh√¥ng t√¨m th·∫•y c·ª•m t·ª´ n√†y.")

    elif text.startswith('/find '):
        keyword = text[6:].strip()
        results = db.search_phrases(user_id, keyword)
        if results:
            msg = "\n".join(f"‚Ä¢ {k} ‚Üí {v}" for k, v in results.items())
            await update.message.reply_text(
                f"üîç K·∫øt qu·∫£ t√¨m ki·∫øm:\n{msg[:4000]}")
        else:
            await update.message.reply_text("‚ùå Kh√¥ng t√¨m th·∫•y c·ª•m t·ª´.")

    elif text == '/history':
        history = db.get_user_history(user_id)
        if history:
            msg = "\n".join(
                f"{i['original']} ‚Üí {i['translated']} ({i['direction']})"
                for i in history)
            await update.message.reply_text(f"üìú L·ªãch s·ª≠ d·ªãch:\n{msg[:4000]}")
        else:
            await update.message.reply_text("‚ùå Ch∆∞a c√≥ l·ªãch s·ª≠ d·ªãch.")

    elif text.startswith('/addadmin '):
        if not is_admin(user_id):
            await update.message.reply_text("‚ö†Ô∏è B·∫°n kh√¥ng c√≥ quy·ªÅn admin.")
            return
        new_admin = text.split()[1]
        admins.add(new_admin)
        save_admins(admins)
        await update.message.reply_text(f"‚úÖ ƒê√£ th√™m admin: {new_admin}")

    elif text.startswith('/removeadmin '):
        if not is_admin(user_id):
            await update.message.reply_text("‚ö†Ô∏è B·∫°n kh√¥ng c√≥ quy·ªÅn admin.")
            return
        target = text.split()[1]
        if target in admins:
            admins.remove(target)
            save_admins(admins)
            await update.message.reply_text(f"‚úÖ ƒê√£ x√≥a admin: {target}")
        else:
            await update.message.reply_text("‚ùå Kh√¥ng t√¨m th·∫•y admin.")

    elif text.startswith('/fast'):
        if not is_admin(user_id):
            await update.message.reply_text("‚ö†Ô∏è B·∫°n kh√¥ng c√≥ quy·ªÅn admin.")
            return

        parts = text.split()
        filter_date = None
        if len(parts) > 1:
            try:
                filter_date = datetime.strptime(parts[1], "%Y-%m-%d").date()
            except ValueError:
                await update.message.reply_text(
                    "‚ùå Ng√†y kh√¥ng h·ª£p l·ªá. ƒê·ªãnh d·∫°ng ƒë√∫ng: /fast YYYY-MM-DD")
                return

        wb = openpyxl.Workbook()
        ws = wb.active
        ws.title = "L·ªãch s·ª≠ d·ªãch"
        ws.append(["User ID", "T√™n nick", "Username", "Original", "Timestamp"])

        for item in db.data["history"]:
            try:
                item_time = datetime.fromisoformat(item["timestamp"])
                if filter_date and item_time.date() != filter_date:
                    continue

                item_user_id = int(item["user_id"])
                user = await context.bot.get_chat(item_user_id)
                full_name = user.full_name or "Kh√¥ng r√µ"
                username = f"@{user.username}" if user.username else "Kh√¥ng c√≥"
            except:
                full_name = "Kh√¥ng l·∫•y ƒë∆∞·ª£c"
                username = "Kh√¥ng l·∫•y ƒë∆∞·ª£c"

            ws.append([
                item["user_id"], full_name, username, item["original"],
                item["timestamp"]
            ])

        for col in ws.columns:
            max_len = max(len(str(cell.value)) for cell in col if cell.value)
            ws.column_dimensions[get_column_letter(
                col[0].column)].width = max_len + 2

        filename = "lich_su_dich.xlsx"
        wb.save(filename)
        await update.message.reply_document(open(filename, "rb"))
        os.remove(filename)

    elif text == '/secure':
        if not is_admin(user_id):
            await update.message.reply_text("‚ö†Ô∏è B·∫°n kh√¥ng c√≥ quy·ªÅn admin.")
            return
        db.data["history"] = []
        db.data["saved_phrases"] = {}
        db.save_db()
        await update.message.reply_text("‚úÖ ƒê√£ x√≥a to√†n b·ªô d·ªØ li·ªáu.")

    else:
        await update.message.reply_text(
            "‚ö†Ô∏è L·ªánh kh√¥ng h·ª£p l·ªá ho·∫∑c ch∆∞a h·ªó tr·ª£.")


# ==== X·ª≠ l√Ω tin nh·∫Øn vƒÉn b·∫£n ====
async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    text = update.message.text.strip()
    user_id = update.message.from_user.id

    if text.startswith('/'):
        return

    result = await detect_and_translate(text, user_id)
    if result:
        await send_translation_with_save_button(update, context, text, result)
    else:
        await update.message.reply_text("üîç Kh√¥ng th·ªÉ nh·∫≠n di·ªán ng√¥n ng·ªØ.")


# ==== L·ªánh /start ====
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(
        "üÄÑ Ë∂ä‰∏≠ÁøªËØëÊú∫Âô®‰∫∫ - Bot d·ªãch Trung Vi·ªát\n\n"
        "üìå C√°ch d√πng:\n"
        "- G·ª≠i vƒÉn b·∫£n ti·∫øng Vi·ªát/Trung ƒë·ªÉ t·ª± ƒë·ªông d·ªãch.\n"
        "- Nh·∫•n n√∫t 'L∆∞u' ƒê·ªÉ l∆∞u c·ª•m t·ª´.\n"
        "- /save <c·ª•m t·ª´>: L∆∞u th·ªß c√¥ng.\n"
        "- /saved: Xem c√°c c·ª•m t·ª´ ƒë√£ l∆∞u.\n"
        "- /delete <c·ª•m t·ª´>: X√≥a c·ª•m t·ª´ ƒë√£ l∆∞u.\n"
        "- /find <t·ª´ kh√≥a>: T√¨m c·ª•m t·ª´ ƒë√£ l∆∞u.\n"
        "- /history: Xem l·ªãch s·ª≠ d·ªãch.\n\n"
        "üìå ‰ΩøÁî®ÊñπÊ≥ï:\n"
        "- ÂèëÈÄÅ‰∏≠Ë∂äÊñáÊñáÊú¨Ëá™Âä®ÁøªËØë.\n"
        "- ÁÇπÂáª'‰øùÂ≠ò'ÊåâÈíÆ‰øùÂ≠òÁü≠ËØ≠.\n"
        "- /saved: Êü•ÁúãÂ∑≤‰øùÂ≠òÁöÑÁü≠ËØ≠.\n"
        "- /delete <Áü≠ËØ≠>: Âà†Èô§Â∑≤‰øùÂ≠òÁöÑÁü≠ËØ≠.\n"
        "- /find <ÂÖ≥ÈîÆËØç>: ÊêúÁ¥¢Â∑≤‰øùÂ≠òÁöÑÁü≠ËØ≠.\n"
        "- /history: Êü•ÁúãÁøªËØëÂéÜÂè≤.\n"
        "üëâ @xukaxuka2k1 code free,fastandsecureüëà")


async def admin_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat_id = update.effective_chat.id

    # Ki·ªÉm tra quy·ªÅn admin
    if not is_admin(update.effective_user.id):
        return await update.message.reply_text("‚ùå B·∫°n kh√¥ng c√≥ quy·ªÅn.")

    admin_commands = ("üìú **ADMIN MENU** üìú\n\n"
                      "üîπ /fast - ...\n"
                      "üîπ /secure - ...\n"
                      "üîπ /delete - L√†m m·ªõi l·∫°i to√†n b·ªô.\n"
                      "üîπ /addadmin - ID L√†m admin.\n"
                      "üîπ /removeadmin - ID Xo√° admin.")

    await update.message.reply_text(admin_commands, parse_mode="Markdown")


async def unknown(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(
        "‚ùì L·ªánh kh√¥ng h·ª£p l·ªá. G√µ /start ƒë·ªÉ xem l·ªánh.\n\n"
        "üéÆ game Caro:\u2003\u2003@Game_carobot\n"
        "üéÆ N·ªëi ch·ªØ:\u2003\u2003\u2003@noi_chu_bot\n"
        "üÄÑ Google :\u2003\u2003@Dichngon_ngubot")


# ==== Kh·ªüi ch·∫°y Bot ====
def main():
    TOKEN = os.getenv("TELEGRAM_BOT_TOKEN")
    if not TOKEN:
        print("‚ùå Ch∆∞a thi·∫øt l·∫≠p TELEGRAM_BOT_TOKEN")
        return

    app = Application.builder().token(TOKEN).build()
    app.add_handler(CommandHandler("start", start))
    app.add_handler(CommandHandler("admin", admin_command))
    app.add_handler(
        CommandHandler([
            "saved", "mysaved", "save", "delete", "find", "history",
            "addadmin", "removeadmin", "fast", "secure"
        ], handle_command))
    app.add_handler(CallbackQueryHandler(button_callback))
    app.add_handler(MessageHandler(filters.COMMAND, unknown))
    app.add_handler(
        MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message))

    print("ü§ñ Bot ƒë√£ kh·ªüi ƒë·ªông...")
    app.run_polling()


if __name__ == '__main__':
    main()
